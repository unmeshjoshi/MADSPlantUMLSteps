title: "Understanding Consensus"
description: "Learn about consensus algorithms, two-phase protocols, and distributed agreement mechanisms. Covers single server problems, clustering, and fault tolerance strategies."
icon: "fas fa-handshake"
category: "Consensus Algorithms"
slides:
  - type: "text"
    title: "Introduction to Consensus"
    bullets:
      - "Consensus is fundamental to distributed systems"
      - "Key challenges in achieving agreement"
      - "Understanding the need for two-phase protocols"
    notes: "Emphasize that consensus is not just about agreement, but about maintaining consistency in the face of failures. This sets up the motivation for the following diagrams."
  
  - type: "diagram"
    title: "Single Server Lacks Fault Tolerance"
    diagramRef: "single_server_problem"
    bullets:
      - "When server is healthy, all requests are processed"
      - "Single point of failure: When the only server fails, all clients are affected"
    notes: "Point out how a single point of failure affects availability. This motivates the need for clustering, which we'll see in the next slides."

  - type: "diagram"
    title: "Consensus: Ensuring Consistency in Clustered Environments"
    diagramRef: "cluster_as_single_node"
    bullets:
      - "The cluster appears as a single entity to clients"
      - "Even with node failures, the cluster continues to function"
      - "But how do we ensure internal consistency?"
    notes: "Introduce the concept that clustering solves availability but creates new challenges around consistency."

  - type: "text"
    title: "Challenge 1: Why Immediate Execution Fails"
    bullets:
      - "Let's try the simplest thing: a server processes a request and tells others"
      - "What could go wrong with this approach?"
      - "Network delays, lost messages, or server crashes lead to inconsistent states"
    notes: "Set up the first major challenge - why naive replication doesn't work."

  - type: "diagram"
    title: "Why Immediate Request Execution Does not Work"
    diagramRef: "single_phase_execution"
    bullets:
      - "Athens executes immediately and tries to propagate"
      - "Network issues prevent updates from reaching other nodes"
      - "Athens crashes after responding to client"
      - "System becomes inconsistent: different servers have different data"
    notes: "Walk through this scenario step by step. Show how network delays, lost messages, or server crashes lead to inconsistent states."

  - type: "text"
    title: "Challenge 2: Trying Two Phases With Majority Quorum"
    bullets:
      - "Majority quorum: A majority of nodes must agree to execute a request"
      - "How can we ensure a majority agrees before a request is considered 'committed'?"
      - "Introduce Phase 1 (Accept): Get majority agreement on the request"
      - "Introduce Phase 2 (Execute): Execute the request once majority agrees" 
    notes: "Introduce the concept of two-phase execution as a solution to the immediate execution problem."

  - type: "diagram"
    title: "Why simple two phase execution is not enough"
    diagramRef: "two_phase_execution"
    bullets:
      - "Phase 1 (Accept): Athens gets majority agreement on the request"
      - "Phase 2 (Execute): Athens executes on all nodes with majority consent"
      - "System is now consistent: all nodes have Counter = 6"
    notes: "Visual walkthrough using the two-phase execution slides to show a successful agreement."

  - type: "text"
    title: "Challenge 3: Failures During Agreement"
    bullets:
      - "What if a server crashes or messages get lost during these two phases?"
      - "Failures can leave the system in an ambiguous state"
      - "Some nodes might know the result, others might not"
    notes: "Introduce the complexity that failures add to the two-phase protocol."

  - type: "diagram"
    title: "The Commit Requests Can Get Lost"
    diagramRef: "two_phase_lost_commits"
    bullets:
      - "Athens gets majority agreement in Phase 1 (Accept)"
      - "Athens executes locally and responds to client early"
      - "Execute messages to other nodes get lost"
      - "Athens crashes before other nodes execute"
    notes: "Show how a server can crash after getting a majority of accepts but before notifying everyone."

  - type: "diagram"
    title: "The Accept Requests Can Get Lost as Well"
    diagramRef: "two_phase_missed_accepts"
    bullets:
      - "Athens accepts request locally"
      - "Accept request to Cyrene gets lost"
      - "Athens proceeds with majority (self + Byzantium)"
      - "Cyrene never received any requests"
    notes: "Show another failure scenario where accept messages are lost."

  # Session 2: Recovery, Concurrency, and The 'Highest Generation' Rule - Approx. 1.5 hours
  - type: "text"
    title: "Adding Recovery Phase"
    bullets:
      - "When a server wants to process a request, it can't just proceed immediately"
      - "First, it must check with a majority: 'Are there any requests already accepted?'"
    notes: "Introduce the concept of checking with majority as a necessary first step, and how this creates the fundamental ambiguity."

  - type: "text"
    title: "Adding Recovery Phase (Continued)"
    bullets:
      - "This check ensures we don't miss previously accepted requests that might have been committed"
      - "Since we only need majority responses (for fault tolerance), ambiguity can arise" 
      - "Only after this check can the server safely proceed with its decision"
    notes: "Introduce the concept of checking with majority as a necessary first step, and how this creates the fundamental ambiguity."

  - type: "diagram"
    title: "Recovery Phase: Checking for Existing Accepted Requests"
    diagramRef: "recovery_phase_check"
    bullets:
      - "Athens wants to process a new request"
      - "First, Athens asks majority: 'Do you have any accepted requests?'"
      - "Nodes respond with any previously accepted requests they have"
      - "Only then can Athens decide how to proceed"
    notes: "Show the recovery phase where a server checks for existing accepted requests before proceeding."

  - type: "text"
    title: "Recovery Ambiguity: The Core Dilemma"
    bullets:
      - "Before executing ANY new request, a server must first check for existing accepted requests"
      - "It queries a majority and might see a request accepted on one server, but not another"
      - "The Dilemma: Was that request committed, or did it only reach one node?"
      - "Since decisions are made with majority responses (for fault tolerance), it's impossible to know for sure!"
    notes: "Introduce the fundamental ambiguity that arises from making decisions with only majority information for fault tolerance."

  - type: "diagram"
    title: "Recovery Ambiguity: The Scenario"
    diagramRef: "recovery_ambiguity_dilemma"
    bullets:
      - "Athens wants to execute a new request and first checks for existing accepted requests"
      - "Athens can only reach majority (Byzantium and Cyrene)"
      - "Byzantium reports: 'I have accepted IncrementCounter'"
      - "Cyrene could not respond or the response gets lost"
    notes: "Show the setup of the ambiguous scenario where Athens gets conflicting information from the majority it can reach."

  - type: "text"
    title: "Recovery Ambiguity: The Impossible Decision"
    bullets:
      - "Athens faces the dilemma: Was IncrementCounter committed or not?"
      - "Two possible scenarios exist, but Athens cannot distinguish between them"
    notes: "Explain the fundamental dilemma and why Athens cannot make the decision with partial information from majority responses."

  - type: "text"
    title: "Recovery Ambiguity: The Impossible Decision (Continued)"
    bullets:
      - "Scenario 1: IncrementCounter WAS committed (previous leader got majority)"
      - "Scenario 2: IncrementCounter was NOT committed (only reached one node)"
      - "Safety requirement: If a value was ever committed, it must NEVER be lost"
    notes: "Explain the fundamental dilemma and why Athens cannot make the decision with partial information from majority responses."

  - type: "text"
    title: "The Safe Path: When in Doubt, Re-Propose"
    bullets:
      - "Since it might have been committed, the only safe action is to assume it was"
      - "Re-run both phases for that request"
      - "This forces the system towards confirming that request is committed"
      - "Quorum overlap ensures we don't 'forget' a previously committed value"
    notes: "Explain why re-proposing is the safe choice and how quorum overlap provides safety."


  - type: "text"
    title: "Recovery Dilemma: Multiple Conflicting Requests"
    bullets:
      - "What if Athens discovers TWO different accepted requests from the majority it can reach?"
      - "Each server in the majority reports a different request"
      - "Athens must decide: Which request should be preserved and re-proposed?"
    notes: "Introduce the more complex scenario where multiple conflicting accepted requests are discovered when checking with majority."

  - type: "diagram"
    title: "Recovery Dilemma: Multiple Conflicting Accepted Requests"
    diagramRef: "recovery_multiple_accepted_requests"
    bullets:
      - "Athens wants to execute a new request and checks with majority"
      - "Byzantium reports: 'I have accepted IncrementCounter'"
      - "Cyrene reports: 'I have accepted DecrementCounter'"
      - "Athens must choose which request to preserve"
    notes: "Show the scenario where Athens discovers two different accepted requests from majority and must apply the highest generation rule to choose safely."

  - type: "text"
    title: "Establishing Authority With Generation Number (Becoming the Leader)"
    bullets:
      - "A node that wants to initiate an agreement must first establish its authority"
      - "It chooses a Generation Number higher than any it's seen before"
      - "Asks a majority quorum to acknowledge this number"
      - "If majority agrees (and haven't acknowledged a higher number), they promise not to accept lower Generation Numbers"
      - "If nodes have previously stored requests, they report them back with their Generation Numbers"
    notes: "Explain the first critical step: establishing leadership authority through generation numbers."

  - type: "diagram"
    title: "Leader Election Process"
    diagramRef: "leader_election_process"
    bullets:
      - "Athens chooses Generation Number 5 (higher than any seen)"
      - "Sends prepare requests to majority (self + Byzantium)"
      - "Nodes promise not to accept requests with lower generation numbers"
      - "Athens becomes Leader for Generation Number 5"
    notes: "Show the step-by-step process of becoming a leader through generation number establishment."

  - type: "text"
    title: "The Leader Sends the Request"
    bullets:
      - "Leader sends the actual request with its Generation Number to majority quorum"
      - "Nodes check Generation Number against their promises"
      - "If it matches promised number (or higher), they store the request but don't execute yet"
      - "If Generation Number is lower than promised, they reject it"
      - "This ensures only the current leader's requests are accepted"
    notes: "Explain how the leader propagates requests while maintaining generation number consistency."

  - type: "diagram"
    title: "Request Propagation with Generation Numbers"
    diagramRef: "request_propagation_generation"
    bullets:
      - "Leader Athens sends request with Generation Number 5"
      - "Byzantium and Cyrene check against their promises"
      - "They store the request but don't execute yet"
      - "System maintains consistency through generation number validation"
    notes: "Visualize how requests are propagated and validated using generation numbers."

  - type: "text"
    title: "Choosing the Request (Recovery)"
    bullets:
      - "When becoming Leader, examine responses from 'Establishing Authority' step"
      - "If nodes reported previously stored requests, choose the one with highest Generation Number"
      - "The 'choose highest generation' helps solve the recovery ambiguity"
      - "If every leader had first checked with majority, and chose the highest generation request, then if any request was ever committed, it would be one with the highest generation"
    notes: "Explain the critical recovery logic that ensures safety during leadership transitions."

  - type: "text"
    title: "Choosing the Request (Recovery) (Continued)"
    bullets:     
      - "This ensures continuity and prevents 'lost' requests that were close to agreement"
      - "Only if no previous requests were reported can Leader propose its own request"
      - "This is the crucial 'highest generation rule' for safety"
    notes: "Explain the critical recovery logic that ensures safety during leadership transitions."

  - type: "text"
    title: "Choosing Highest Generation: Why the Rule Works"
    bullets:
      - "If any request was ever committed, it should be the one with the highest generation"
      - "This rule works because of a fundamental mathematical property: quorum overlap"
    notes: "Emphasize that this is the mathematical foundation that makes consensus algorithms work. The overlap property is what transforms the highest generation rule from a heuristic into a safety guarantee. This principle applies to all quorum-based consensus systems, not just Paxos."

  - type: "text"
    title: "Choosing Highest Generation: Why the Rule Works"
    bullets:
      - "In a system of N nodes, any two majorities must share at least one node"
      - "Example: With 5 nodes, any two groups of 3 must overlap by 1 node"
      - "This overlap ensures every future leader will see evidence of past commitments"
      - "The highest generation rule + quorum overlap = guaranteed safety"
    
  - type: "diagram"
    title: "Recovery: Choosing the Highest Generation Request"
    diagramRef: "recovery_highest_generation"
    bullets:
      - "New leader discovers multiple stored requests from previous attempts"
      - "Chooses request with Generation Number 4 (highest found)"
      - "Must re-propose this request with new, higher Generation Number 5"
      - "Ensures no previously committed values are lost"
    notes: "Show how the highest generation rule works during recovery scenarios."

  - type: "text"
    title: "Ensuring Majority Agreement & Execution"
    bullets:
      - "Even if Leader adopts a request from previous round, it must send it again with new, higher Generation Number"
      - "Previous attempt might have failed before reaching true majority (Remember the recovery ambiguity?)"
    notes: "Explain the final step: ensuring committed requests are executed in proper order."

  - type: "text"
    title: "Ensuring Majority Agreement & Execution (Continued)"
    bullets:
      - "By getting current majority to store it with new Generation Number, Leader solidifies the request's status"
      - "Only once request is committed (agreed by majority) can nodes execute it"
    notes: "Explain the final step: ensuring committed requests are executed in proper order."

  - type: "diagram"
    title: "From Agreement to Execution"
    diagramRef: "agreement_to_execution"
    bullets:
      - "Leader gets majority agreement on request with Generation Number 5"
      - "Request is now committed and safe to execute"
      - "All nodes execute in the same order"
      - "System maintains consistent state across all nodes"
    notes: "Show the final step from consensus agreement to actual execution."

  - type: "text"
    title: "The Complete Consensus Flow"
    bullets:
      - "1. Establish Authority: Get majority to promise higher Generation Number"
      - "2. Choose Request: Pick highest generation request from recovery or propose new"
      - "3. Get Agreement: Send selected request with new Generation Number to majority"
      - "4. Execute: Only execute committed requests in proper order"
      - "This ensures all nodes agree on same sequence and maintain consistent state"
    notes: "Summarize the complete four-step consensus process before revealing it's Paxos."

  - type: "diagram"
    title: "Quorum Overlap: Mathematical Foundation"
    diagramRef: "quorum_overlap_foundation"
    bullets:
      - "Scenario: Two different consensus rounds with different majority quorums"
      - "Round 1: Athens, Byzantium, Cyrene (majority) accept IncrementCounter"
      - "Round 2: Cyrene, Delphi, Ephesus (majority) run recovery phase"
      - "Cyrene is the overlap node - guarantees information transfer"
      - "This overlap ensures no committed request can be lost"
    notes: "Visually demonstrate how quorum overlap works in practice. Show two different majority quorums and how their overlap guarantees that information about committed requests is preserved across different consensus rounds."

  - type: "text"
    title: "Challenges in Practice"
    bullets:
      - "Livelock: Competing proposers can prevent progress"
      - "Solution: Random backoff and leader election"
      - "Single Request Problem: Once a request is committed, no other request can be executed"
      - "Solution: Replicated Log of Requests"
    notes: "Discuss practical challenges and solutions."

  - type: "diagram"
    title: "Livelock Problem and Solutions"
    diagramRef: "livelock_scenario"
    bullets:
      - "Competing proposers can interfere with each other indefinitely"
      - "Random backoff helps break the cycle"
      - "Stable leader election is a better long-term solution"
    notes: "Show how livelock occurs and how to resolve it."

  # Session 4: From Single Value to Replicated Logs
  - type: "text"
    title: "Limitation: Accepted Requests Never Forgotten"
    bullets:
      - "Once a request is accepted by any node, it can NEVER be forgotten"
      - "Safety requirement: If it might have been committed, we must preserve it"
      - "This creates a fundamental limitation for our current approach"
    notes: "Introduce the key limitation that leads to the need for replicated logs."

  - type: "diagram"
    title: "Why Accepted Requests Cannot Be Forgotten"
    diagramRef: "why_accepted_values_cannot_be_forgotten"
    bullets:
      - "Critical safety property: Once accepted by quorum, values must be preserved"
      - "Forgetting accepted values can lead to safety violations"
      - "Two different values could be committed, breaking consensus"
      - "The 'highest generation rule' prevents this by preserving accepted values"
    notes: "Show the detailed scenario of what happens when accepted values are forgotten and why this violates safety. This is a fundamental property that makes single-value consensus limited."

  - type: "text"
    title: "The Single-Request Problem"
    bullets:
      - "Our current consensus can only agree on ONE request ever"
      - "Once a request is committed, no other request can be executed"
      - "Example: If 'IncrementCounter' is committed, 'DecrementCounter' can never be processed"
      - "This makes the system unusable for real applications!"
    notes: "Explain why single-value consensus is insufficient for practical systems."

  - type: "diagram"
    title: "Single-Value Consensus Limitation"
    diagramRef: "single_value_limitation"
    bullets:
      - "IncrementCounter is committed and executed"
      - "New request DecrementCounter arrives"
      - "System cannot process it - consensus slot is 'used up'"
      - "No way to handle multiple requests over time"
    notes: "Show the fundamental limitation of single-value consensus."

  - type: "text"
    title: "Solution: Replicated Log of Requests"
    bullets:
      - "Instead of agreeing on a single value, maintain an ordered log of requests"
      - "Each log slot can hold one committed request"
      - "Run consensus separately for each slot"
      - "Execute requests in log order to maintain consistency"
    notes: "Introduce the concept of replicated logs as the solution."

  - type: "diagram"
    title: "Replicated Log Concept"
    diagramRef: "replicated_log_concept"
    bullets:
      - "Each node maintains an ordered log of requests"
      - "Slot 1: IncrementCounter, Slot 2: DecrementCounter, Slot 3: ..."
      - "Consensus ensures all nodes have the same log"
      - "Requests are executed in log order"
    notes: "Show the basic concept of replicated logs."

  - type: "text"
    title: "Multi-Slot Consensus Process"
    bullets:
      - "For each new request, find the next available slot"
      - "Run full consensus (generation number + recovery + two phases) for that slot"
      - "If slot already has an accepted request, commit it first, then try next slot"
      - "Continue until our request gets committed in some slot"
    notes: "Explain how consensus works across multiple slots."

  - type: "diagram"
    title: "Multi-Slot Consensus in Action"
    diagramRef: "multi_slot_consensus"
    bullets:
      - "Athens wants to commit DecrementCounter"
      - "Slot 1 already has IncrementCounter - commit it first"
      - "Try DecrementCounter in Slot 2"
      - "Success! Both requests now committed in order"
    notes: "Show how multi-slot consensus handles multiple requests."

  - type: "text"
    title: "Execution Challenge: The High-Water Mark"
    bullets:
      - "Problem: Log might have gaps (some slots committed, others not)"
      - "Cannot execute immediately after commit - might break ordering"
      - "Solution: High-water mark - index before which ALL slots are committed"
      - "Execute requests only up to the high-water mark"
    notes: "Introduce the execution challenge and high-water mark solution."

  - type: "diagram"
    title: "High-Water Mark Execution"
    diagramRef: "high_water_mark_execution"
    bullets:
      - "Log state: Slot 1 (committed), Slot 2 (uncommitted), Slot 3 (committed)"
      - "High-water mark = 0 (no consecutive committed slots from start)"
      - "Cannot execute Slot 3 until Slot 2 is committed"
      - "Ensures strict ordering of execution"
    notes: "Show how high-water mark ensures ordered execution."

  - type: "text"
    title: "Complete Multi-Paxos Flow"
    bullets:
      - "1. Client sends request to leader"
      - "2. Leader finds next available slot"
      - "3. Run consensus for that slot (with recovery)"
      - "4. Update high-water mark when consecutive slots are committed"
      - "5. Execute all requests up to high-water mark in order"
    notes: "Summarize the complete Multi-Paxos process."

  - type: "diagram"
    title: "Multi-Paxos: Complete Flow"
    diagramRef: "multi_slot_consensus_complete_flow"
    bullets:
      - "Multiple clients sending requests"
      - "Leader assigns slots and runs consensus"
      - "Handles recovery and slot conflicts"
      - "Maintains high-water mark for safe execution"
    notes: "Show the complete Multi-Paxos system in action."

  - type: "text"
    title: "Multi-Paxos Optimization: Server-Level Leadership"
    bullets:
      - "Key insight: Leader election (prepare phase) can be executed only once at server level"
      - "Generation number maintained at server level to detect conflicts during recovery and execution"
      - "When triggered, server runs leader election to establish generation number"
      - "New leader then runs recovery for all uncommitted log entries across all servers"
    notes: "Introduce the key optimization that makes Multi-Paxos practical - separating leadership from per-slot consensus."

  - type: "text"
    title: "Multi-Paxos Recovery Process"
    bullets:
      - "Recovery phase: For each uncommitted slot, choose highest generation entry found"
      - "Re-run two phases (accept and commit) with new generation number for recovered entries"
      - "Use high-water mark mechanism to ensure safe execution order"
      - "After recovery completes, leader can execute just accept/commit phases for new requests"
      - "Leader knows which next slot to use - no more prepare phases needed"
    notes: "Explain the recovery process and how it enables the optimization of skipping prepare phases for subsequent requests."

  - type: "diagram"
    title: "Multi-Paxos: Initial Leader Election"
    diagramRef: "multi_paxos_initial_leader_election"
    bullets:
      - "System startup - no existing leader"
      - "Athens triggers leader election and establishes generation number"
      - "Athens becomes leader and starts processing client requests"
      - "Subsequent requests use only accept/commit phases (no prepare needed)"
      - "Demonstrates the Multi-Paxos optimization from clean state"
    notes: "Show how Multi-Paxos works from system startup, demonstrating the initial leader election and subsequent optimization for client requests."

  - type: "diagram"
    title: "Multi-Paxos: Leader Failure and Recovery"
    diagramRef: "multi_paxos_leader_failure_recovery"
    bullets:
      - "Existing leader fails or gets disconnected during operation"
      - "New leader election triggered on another server"
      - "New leader establishes higher generation number"
      - "Runs recovery for all pending/uncommitted slots"
      - "Executes client requests from next open slot onwards using only accept/commit phases"
    notes: "Show the complete Multi-Paxos leader failure and recovery cycle, demonstrating how the optimization works in practice when leadership changes."

  - type: "text"
    title: "Heartbeat Mechanism: Detecting Leader Failures"
    bullets:
      - "Problem: How do followers know when the leader has failed?"
      - "Solution: Leader periodically sends heartbeat messages to all followers"
      - "Heartbeat interval should be greater than network round-trip time between servers"
      - "Followers wait for timeout interval (multiple of heartbeat interval)"
      - "If heartbeat doesn't arrive within timeout, followers trigger leader election"
    notes: "Introduce the heartbeat pattern as described in Martin Fowler's Patterns of Distributed Systems. Emphasize the importance of timely failure detection for maintaining system availability."

  - type: "diagram"
    title: "Heartbeat Pattern: General Concept"
    diagramRef: "heartbeat_general_concept"
    bullets:
      - "Server periodically sends heartbeat messages to indicate liveness"
      - "Other servers maintain timeout timers"
      - "Timeout expiry indicates server failure"
      - "Enables timely detection of failures in distributed systems"
    notes: "Show the basic heartbeat pattern as a general distributed systems concept before applying it to Multi-Paxos. Emphasize timing relationships and failure detection mechanism."

  - type: "text"
    title: "Heartbeat in Multi-Paxos Context"
    bullets:
      - "Leader sends heartbeats while processing client requests (can piggyback on regular messages)"
      - "During idle periods, leader sends explicit heartbeat messages"
      - "Followers reset their timeout whenever they receive any message from current leader"
      - "Timeout expiry triggers immediate leader election with higher generation number"
      - "Ensures rapid detection of leader failures and minimal service disruption"
    notes: "Explain how heartbeat mechanism integrates with Multi-Paxos, including optimization opportunities like piggybacking heartbeats on regular consensus messages."

  - type: "diagram"
    title: "Multi-Paxos: Heartbeat and Failure Detection"
    diagramRef: "multi_paxos_heartbeat_failure_detection"
    bullets:
      - "Leader Athens sends periodic heartbeats to followers"
      - "Followers maintain timeout timers for leader liveness"
      - "Athens fails and heartbeats stop arriving"
      - "Timeout expires on followers, triggering leader election"
      - "Demonstrates the complete failure detection and recovery cycle"
    notes: "Show how heartbeat mechanism works in practice with Multi-Paxos, including timing relationships and the transition from heartbeat failure to leader election."

  - type: "text"
    title: "Client Retry Problem in Distributed Systems"
    bullets:
      - "When servers fail, clients don't know if their requests were processed"
      - "Clients must retry to ensure their requests are handled"
      - "Problem: Retries can cause duplicate execution if the original request was processed"
      - "Example: Transfer $100 - if executed twice, transfers $200!"
      - "Need mechanism to handle retries safely while maintaining exactly-once semantics"
    notes: "Introduce the fundamental client retry problem that occurs in all distributed systems. This is separate from consensus but equally important for production systems."

  - type: "text"
    title: "Idempotent Receiver Pattern: Safe Request Handling"
    bullets:
      - "Solution: Each client assigns unique (client ID, request number) to every request"
      - "Servers maintain deduplication table: (clientID, requestNumber) â†’ executionResult"
      - "Table updated after each committed request is executed"
      - "When new request arrives: check deduplication table first"
      - "If found: return cached result without consensus or execution"
    notes: "Explain the Idempotent Receiver pattern using a separate deduplication table that's maintained as derived state from the consensus log."

  - type: "diagram"
    title: "Idempotent Receiver Pattern in Action"
    diagramRef: "idempotent_receiver_pattern"
    bullets:
      - "Client sends request with unique ID"
      - "Server processes request and caches response"
      - "Server crashes before responding to client"
      - "Client retries with same request ID"
      - "Server detects duplicate and returns cached response"
    notes: "Show the complete flow of the Idempotent Receiver pattern, demonstrating how it prevents duplicate execution while ensuring clients get responses."

  - type: "text"
    title: "From Basic Consensus to Production Systems"
    bullets:
      - "We've built the foundation: single-value consensus with recovery"
      - "Extended it to replicated logs for practical use"
      - "This is the core of systems like Chubby, etcd, and Raft"
      - "Real systems add optimizations, but the principles remain the same"
    notes: "Connect the concepts learned to real-world distributed systems."

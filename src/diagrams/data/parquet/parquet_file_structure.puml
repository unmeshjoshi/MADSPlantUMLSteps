@startuml
!include ../../../style.puml

' Scale the diagram for better visibility
scale 1.5

' Improve spacing and font sizes
skinparam defaultFontSize 14
skinparam rectangleFontSize 12
skinparam rectanglePadding 20
skinparam rectangleMargin 10

title Parquet File Structure

' [step1 {"name":"File Overview"}]
note as N1
  **File Header:**
  • Every Parquet file starts with "PAR1"
  • Identifies the file format
  • Fixed 4-byte magic number
  
  **File Footer:**
  • Contains complete schema definition
  • Row group metadata & locations
  • Column chunk statistics (min/max)
  • Key-value metadata pairs
end note

rectangle "Parquet File Structure\n(Binary Format)" as ParquetFile #LightBlue {
  rectangle "File Header\n(Start of File)" as Header #LightGreen {
    rectangle "PAR1 Magic Number\n(4 bytes)" as HeaderMagic #Orange
  }
  
  rectangle "Data Section\n(Row Groups & Column Chunks)" as DataSection #LightYellow
  
  rectangle "File Footer\n(End of File)" as Footer #LightCoral {
    rectangle "File Metadata\n(Schema & Statistics)" as FileMetadata #Orange
    rectangle "Footer Length\n(4 bytes)" as FooterLength #Orange
    rectangle "PAR1 Magic Number\n(4 bytes)" as FooterMagic #Orange
  }
}

N1 --> ParquetFile
' [/step1]

' [step2 {"name":"Data Section Details", "newPage":"true"}]
note as N2
  **Storage Hierarchy:**
  • Row Groups: ~128 MiB each (configurable)
  • Column Chunks: One per column per row group
  • Pages: ~1 MiB each (smallest I/O unit)
  • Enables efficient columnar access patterns
end note

rectangle "Data Section Hierarchy\n(Nested Structure)" as DataDetails #LightCyan {
  rectangle "Row Group 1\n(~128 MiB default)" as RG1 #LightGreen {
    rectangle "Column Chunk 1-1\n(Column A)" as CC11 #LightYellow {
      rectangle "Page 1-1-1\n(~1 MiB)" as P111 #Orange
      rectangle "Page 1-1-2\n(~1 MiB)" as P112 #Orange
      rectangle "... more pages" as P11x #Orange
    }
    
    rectangle "Column Chunk 1-2\n(Column B)" as CC12 #LightYellow {
      rectangle "Page 1-2-1\n(~1 MiB)" as P121 #Orange
      rectangle "Page 1-2-2\n(~1 MiB)" as P122 #Orange
      rectangle "... more pages" as P12x #Orange
    }
    
    rectangle "... more columns" as CC1x #LightYellow
  }
  
  rectangle "Row Group 2\n(~128 MiB default)" as RG2 #LightGreen {
    rectangle "Column Chunk 2-1\n(Column A)" as CC21 #LightYellow {
      rectangle "Page 2-1-1\n(~1 MiB)" as P211 #Orange
      rectangle "Page 2-1-2\n(~1 MiB)" as P212 #Orange
      rectangle "... more pages" as P21x #Orange
    }
    
    rectangle "Column Chunk 2-2\n(Column B)" as CC22 #LightYellow {
      rectangle "Page 2-2-1\n(~1 MiB)" as P221 #Orange
      rectangle "Page 2-2-2\n(~1 MiB)" as P222 #Orange
      rectangle "... more pages" as P22x #Orange
    }
    
    rectangle "... more columns" as CC2x #LightYellow
  }
  
  rectangle "... more row groups" as RGx #LightGreen
}

N2 --> DataDetails
' [/step2]

' [step3 {"name":"Page Structure", "newPage":"true"}]
note as N3
  **Dictionary Page:**
  • Appears once per column chunk (if used)
  • Contains unique values for dictionary encoding
  • Reduces storage space for repeated values
  • Referenced by index in data pages
  
  **Data Page Components:**
  • Definition levels: Handle NULL/missing values
  • Repetition levels: Handle nested/repeated data
  • Encoded values: Actual data (may use dictionary)
  • Multiple encoding schemes supported
end note

rectangle "Page Types & Internal Structure" as PageStructure #LightPink {
  rectangle "Dictionary Page\n(Optional - Once per Column Chunk)" as DictPage #LightGreen {
    rectangle "Page Header\n(Type, Size, Counts)" as DictHeader #Orange
    rectangle "Dictionary Values\n(Unique values for encoding)" as DictValues #LightYellow
  }
  
  rectangle "Data Page\n(Contains Actual Data)" as DataPage #LightBlue {
    rectangle "Page Header\n(Type, Size, Counts)" as DataHeader #Orange
    rectangle "Definition Levels\n(NULL value handling)" as DefLevels #LightCyan
    rectangle "Repetition Levels\n(Nested data handling)" as RepLevels #LightCyan
    rectangle "Encoded Values\n(Compressed data)" as Values #LightYellow
  }
}

N3 --> PageStructure
' [/step3]

' [step4 {"name":"Footer Details", "newPage":"true"}]
note as N4
  **Schema Information:**
  • Complete column definitions
  • Data types (INT32, INT64, FLOAT, etc.)
  • Nesting structure for complex types
  • Logical type annotations
  
  **Column Chunk Metadata:**
  • File offset & size in bytes
  • Statistics (min/max/null_count)
  • Encoding & compression info
  • Bloom filter metadata (if present)
end note

rectangle "Footer Metadata Structure\n(Critical for Query Planning)" as FooterDetails #LightSalmon {
  rectangle "File Metadata\n(Complete File Information)" as FileMetadataDetails #LightBlue {
    rectangle "Version\n(Parquet format version)" as Version #Orange
    rectangle "Schema\n(Complete table schema)" as Schema #LightGreen
    rectangle "Number of Rows\n(Total row count)" as NumRows #Orange
    rectangle "Row Group Metadata\n(Per-group information)" as RGMetadata #LightYellow {
      rectangle "Row Group 1 Metadata" as RG1Meta #LightCyan {
        rectangle "Total Byte Size\n(Compression info)" as RG1Size #White
        rectangle "Number of Rows\n(Row count)" as RG1Rows #White
        rectangle "Column Chunk Metadata\n(Per-column stats)" as CC1Meta #White
      }
      rectangle "Row Group 2 Metadata" as RG2Meta #LightCyan
      rectangle "... more row groups" as RGxMeta #LightCyan
    }
    rectangle "Key-Value Metadata\n(Custom properties)" as KVMeta #Orange
  }
}

N4 --> FooterDetails
' [/step4]

' [step5 {"name":"Reading Process", "newPage":"true"}]
note as N5
  **Efficient Reading Strategy:**
  1. Minimal initial read (8 bytes) to locate footer
  2. Read and parse footer metadata (~32 KiB)
  3. Use statistics for predicate pushdown
  4. Skip entire row groups when possible
  5. Read only required columns from selected row groups
  6. Massive I/O savings through metadata-driven queries
end note

rectangle "Efficient Reading Process\n(Metadata-First Approach)" as ReadProcess #LightPink {
  rectangle "Step 1: Read Footer Location\n(Last 8 bytes of file)" as Step1 #LightGreen
  rectangle "Step 2: Read Footer Metadata\n(Using footer length)" as Step2 #LightYellow
  rectangle "Step 3: Parse Schema & Statistics\n(Build query plan)" as Step3 #LightBlue
  rectangle "Step 4: Row Group Pruning\n(Skip unnecessary groups)" as Step4 #LightCyan
  rectangle "Step 5: Column Projection\n(Read only required columns)" as Step5 #Orange
}

Step1 -down-> Step2 : "Footer length\n(4 bytes)"
Step2 -down-> Step3 : "Complete metadata\n(~32 KiB typical)"
Step3 -down-> Step4 : "Statistics enable\npredicate pushdown"
Step4 -down-> Step5 : "Only read relevant\nrow groups"

N5 --> ReadProcess
' [/step5]

@enduml
